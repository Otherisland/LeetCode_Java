

## KMP 算法

参考网址：[KMP 模式匹配算法——详细讲解、清晰易懂-CSDN 博客](https://blog.csdn.net/m0_58386652/article/details/144316661)

### 算法原理

**前缀表** 中记录的是字符串中的每个子串的 **最大相等前后缀的长度**

| index       | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ----------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| char        | a    | b    | a    | a    | a    | b    | a    | a    | c    | a    |
| 前缀表/长度 | -    | -    | -    | -    | -    | -    | -    | -    | -    | -    |
| next/索引   | -    | -    | -    | -    | -    | -    | -    | -    | -    | -    |

例如字符串 `ABCxyzABC` 的最长公共前后缀为 **ABC**
`ABCXYABC的` 真 **前缀**：A，AB, **ABC**, ABCx, ABCxy, ABCxyz, ABCxyzA, ABCxyzAB
`ABCXYABC的` 真 **后缀**：BCxyzABC, CxyzABC, xyzABC, yzABC, zABC, **ABC**, BC, C

所以最大相同前后缀的 **长度为：3**

**前缀表 ** 表示了前后缀相同的部分的长度

```
needle = `abaaabaaba`
```

对于每一个新增的字符，它们的前后缀依次是：

| 新增 |  j   |   前缀   |        |   后缀   | 共同前后缀 | 长度 |
| :--: | :--: | :------: | :----: | :------: | :--------: | :--: |
|  a   |  0   |          |   a    |          |            |  0   |
|  b   |  1   |          |   ab   |          |            |  0   |
|  a   |  2   |  **a**   |   b    |  **a**   |     a      |  1   |
|  a   |  3   |  **a**   |   ba   |  **a**   |     a      |  1   |
|  a   |  4   |  **a**   |  baa   |  **a**   |     a      |  1   |
|  b   |  5   |  **ab**  |  aaa   |  **ab**  |     ab     |  2   |
|  a   |  6   | **aba**  |   a    | **aba**  |    aba     |  3   |
|  a   |  7   | **abaa** |        | **abaa** |    abaa    |  4   |
|  b   |  8   |  **ab**  | aaaba  |  **ab**  |     ab     |  2   |
|  a   |  9   |  **a**   | abaaab |  **a**   |     a      |  1   |

按照数组，从前到后判断即为

| j    | [0]           | [1]           | [2]           | [3]           | [4]           | [5]           | [6]           | [7]           | [8]           | [9]          | 共同前后缀 | 长度 |
| ---- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ---------- | ---------- |
| -   | **a**         |               |               |               |               |               |               |               |               |               |            | **0** |
| Step.1 | **a**&#10006; | **b**&#10006; |               |               |               |               |               |               |               |               |            | **0** |
| Step.2 | **a**&#10004; | b             | **a**&#10004; |               |               |               |               |               |               |               | a          | **1**   |
| Step.3 | **a**         | **b**&#10006; | a             | **a**&#10006; |               |               |               |               |               |               | a          | **1**     |
| Step.4 | **a**         | **b**&#10006; | a             | a             | **a**&#10006; |               |               |               |               |               | a          | **1**     |
| Step.5 | **a**         | **b**&#10004; | a             | a             | **a**         | **b**&#10004; |               |               |               |               | ab         | **2**    |
| Step.6 | **a**         | **b**         | **a**&#10004; | a             | **a**         | **b**         | **a**&#10004; |               |               |               | aba        | **3**  |
| Step.7 | **a**         | **b**         | **a**         | **a**&#10004; | **a**         | **b**         | **a**         | **a**&#10004; |               |               | abaa       | **4**  |
| Step.8 | **a**         | **b**         | a             | a             | **a**&#10006; | b             | a             | **a**         | **b**&#10006; |               | ab         | **0**    |
| Step.9 | **a**&#10004; | b             | a             | a             | a             | b             | a             | a             | b             | **a**&#10004; | a          | **1**     |

#### 更新前缀表

根据上述表，可得前缀表为：**（前缀表即为新增字符时，对应的共同前后缀长度）**

| j               | [0]   | [1]   | [2]   | [3]   | [4]   | [5]   | [6]   | [7]   | [8]   | [9]   |
| --------------- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |
| char            | a     | b     | a     | a     | a     | b     | a     | a     | b     | a     |
| **前缀表/长度** | **0** | **0** | **1** | **1** | **1** | **2** | **3** | **4** | **2** | **3** |

#### 更新next数组

根据上述表，可得next数组为：**（next数组为索引值，也就是前缀表数值-1，当新增字符处理时，对比对应的next数值）**

| j             | [0]   | [1]   | [2]   | [3]   | [4]   | [5]   | [6]   | [7]   | [8]   | [9]   |
| ------------- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |
| char          | a     | b     | a     | a     | a     | b     | a     | a     | b     | a     |
| 前缀表/长度   | 0↘    | 0↘    | 1↘    | 1↘    | 1↘    | 2↘    | 3↘    | 4↘    | 2↘    | 3↘    |
| **next/索引** | **-** | **0** | **0** | **1** | **1** | **1** | **2** | **3** | **4** | **2** |

#### 具体实现

**其中，**

**Step.8 的具体实现**为

```java
if(needle[next=4]!=needle[8]) 
    //对比 `a`和`b` 不相等时，
    //`next=4`相当于`j=8`可以放到`j=4`的列，并继承它的 `next` 值
```

| j             | [0]    | [1]    | [2]    | [3]    | [4]    |      | [4]    | [5]    | [6]    | [7]    | [8]   | 共同前后缀 |
| -------------------- | ----- | ----- | ----- | ----- | ----- | ---- | ----- | ----- | ----- | ----- | ----- | ---------- |
| Step.8 | **a** | **b** | **a** | **a** | a     |      | **a** | **b** | **a** | **a** | b     | ?          |
| 前缀表/长度 | **0**↘ | **0↘** | **1**↘ | **1↘** | **1↘** |      | **1**↘ | **2↘** | **3↘** | **4**↘ | ?     |            |
| next/索引 | -     | **0** | **0** | **1** | **1** |      | **1** | **1** | **2** | **3** | **4** |            |

此时`[0]-[3]`与`[4]-[7]`是相同的

| j      | 0     | 1     | 2     | 3     | 4    |
| ------ | ----- | ----- | ----- | ----- | ---- |
| Step.8 | **a** | **b** | **a** | **a** | a    |

| j      | 4     | 5     | 6     | 7     | 8    |
| ------ | ----- | ----- | ----- | ----- | ---- |
| Step.8 | **a** | **b** | **a** | **a** | b    |

**其中，**[8]处的`next=4`相当于`j=8`可以放到`j=4`的列，并继承它的 `next` 值，即

| j           | [0]    | [1]    | [2]    | [3]    | [8]    |
| ----------- | ------ | ------ | ------ | ------ | ------ |
| Step.8.1    | **a**  | **b**  | a      | **a**  | **b**  |
| 前缀表/长度 | **0**↘ | **0↘** | **1↘** | **1↘** | ?      |
| next/索引   | -      | **0**  | **0**  | **1**  | **1**✔ |

此时应计算 `abaab` 中的**最大共同前后缀长度**，ab | a | ab

```java
if(needle[next=1]!=needle[8]) 
    //对比 `b`和`b` 相等时，
    //长度=next+1
```

即，最大共同前后缀长度为 **2**

| j           | [0]    | [1]    | [2]    | [3]    | [8]    |
| ----------- | ------ | ------ | ------ | ------ | ------ |
| Step.8.1    | **a**  | **b**  | a      | **a**  | **b**  |
| 前缀表/长度 | **0**↘ | **0↘** | **1↘** | **1↘** | **2**✔ |
| next/索引   | -      | **0**  | **0**  | **1**  | **1**  |

**重新放回到原来位置**，并且 next 值也修改成原本的值，即

| j             | [0]   | [1]   | [2]   | [3]   | [4]   | [5]   | [6]   | [7]   | [8]    | [9]   |
| -------------------- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ---------- |
| Step.9 | **a** | b | a | a | a | b | a | a | b | **a**    |
| 前缀表/长度 | 0↘ | 0↘ | 1↘ | 1↘ | 1↘ | 2↘ | 3↘ | 4↘ | **2**↘ | ? |
| next/索引 | -     | **0** | **0** | **1** | **1** | **1** | **2** | **3** | **4** | 2✔ |

**Step.9 的具体实现**为

```java
if(needle[next=2]!=needle[9]) 
    //对比 `a`和`a` 相等时，
    //长度=next+1
```

即，最大共同前后缀长度为 **3**，aba | aaba | aba

| j           | [0]   | [1]   | [2]   | [3]   | [4]   | [5]   | [6]   | [7]   | [8]   | [9]   | 共同前后缀 |
| ----------- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ---------- |
| Step.9      | **a** | b     | a     | a     | a     | b     | a     | a     | b     | **a** | **a**      |
| 前缀表/长度 | 0↘    | 0↘    | 1↘    | 1↘    | 1↘    | 2↘    | 3↘    | 4↘    | 2↘    | 3✔    |            |
| next/索引   | -     | **0** | **0** | **1** | **1** | **1** | **2** | **3** | **4** | **2** |            |

#### 前缀表

| j            | [0]  | [1]  | [2]  | [3]  | [4]  | [5]  | [6]  | [7]  | [8]  | [9]  |
| ---------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| char             | a    | b    | a    | a    | a    | b    | a    | a    | b    | a    |
| 前缀表/长度 | 0    | 0    | 1    | 1    | 1    | 2    | 3    | 4    | 2    | 3    |
| next/索引      | -    | -    | -    | -    | -    | -    | -    | -    | -    | -    |

### 代码实现

#### next 数组的代码实现

可以计算出当前匹配串 T 的 next 数组

```java
void get_next(string T, int *next) {
	next[0] = -1;
	int i = 0;
	int j = -1;
	
	while(i < T.size() - 1) {
		//T[i]表示后缀的单个字符
		//T[j]表示前缀的单个字符
		if(j == -1 || T[i] == T[j]){//
			++i;
			++j;
			next[i] = j;
		} else {
			//如果字符不相同，则j值回溯
			j = next[j];
		}
	}
}

```

#### KMP 代码实现

```java
int KMP(string S, string T) {
    int ans = -1;
    // i用于遍历主串S
    int i = 0;
    // j用于遍历匹配串T
    int j = 0;
    int next[255]; // 这里初始长度为255,需自行调整
    // 对T做分析，得到next数组
    get_next(T, next);
    while (i < S.size()) {
        // 匹配成功则继续向下一个字符进行匹配
        if (j == -1 || S[i] == T[j]) {
            ++i;
            ++j;
        }
        // 匹配失败进行回溯
        else {
            // j回溯到合适的位置
            j = next[j];
        }
        if (j == T.size()) {
            ans = i - T.size();
            break;
        }
    }
    return ans;
}

```

